import random
from math import *
from scipy.spatial import ConvexHull
from shapely.geometry import Polygon
import numpy as np
import pandas as pd


def 太阳角度计算(月份, 时间):
    """
    计算出太阳高度角和方位角
      参数：

      月份(int):第几月

      时间(int):小时数

      返回值：

      高度角(弧度制)和方位角(弧度制,以北为正方向顺时针)的元组
   """
    指定日期列表 = [-59, -28, 0,
                    31, 61, 92,
                    122, 153, 184,
                    214, 245, 275]
    D = 指定日期列表[月份 - 1]
    纬度 = 39.4 * pi / 180
    太阳赤纬角 = asin(sin((2 * pi * D) / 365) * sin((2 * pi * 23.45) / 360))
    太阳时角 = pi * (时间 - 12) / 12
    太阳高度角 = asin(cos(太阳赤纬角) * cos(太阳时角) * cos(纬度) + sin(太阳赤纬角) * sin(纬度))
    
    if 1.00001 > (sin(太阳赤纬角) - sin(太阳高度角) * sin(纬度)) / (cos(太阳高度角) * cos(纬度)) > 1:
        太阳方位角 = 0
    elif -1.00001 < (sin(太阳赤纬角) - sin(太阳高度角) * sin(纬度)) / (cos(太阳高度角) * cos(纬度)) < -1:
        太阳方位角 = pi
    elif cos(太阳高度角) != 0:
        
        太阳方位角 = acos((sin(太阳赤纬角) - sin(太阳高度角) * sin(纬度)) / (cos(太阳高度角) * cos(纬度)))
    else:
        太阳方位角 = 0
    
    if 时间 > 12:
        太阳方位角 = 2 * pi - 太阳方位角
    
    return (太阳高度角, 太阳方位角)


def 太阳光线向量计算(月份, 时间):
    """
    计算太阳光线向量

    参数：

    月份(int):几月数字

    时间(float):小时时间

    返回值：

    太阳光线向量(np数组)

    """
    太阳高度角, 太阳方位角 = 太阳角度计算(月份, 时间)
    太阳方位角 = 太阳方位角 - pi / 2
    x = -cos(太阳高度角) * cos(太阳方位角)
    y = -cos(太阳高度角) * sin(太阳方位角)
    z = -sin(太阳高度角)
    return np.array([x, y, z])


def 定日镜法向量(太阳光线方向向量, 定日镜坐标, 塔高=84, 安装高度=4):
    """
      计算出某定日镜法向向量

      参数：

      太阳光线方向向量(np数组)

      定日镜坐标(np数组/元组)

      塔高(float)

      安装高度(float)

      返回值：

      定日镜法向方向向量
    """
    x, y = 定日镜坐标[0:2]
    z = 安装高度 - 塔高
    反射后方向向量反向 = np.array(
        [x / sqrt(x ** 2 + y ** 2 + z ** 2), y / sqrt(x ** 2 + y ** 2 + z ** 2), z / sqrt(x ** 2 + y ** 2 + z ** 2)])
    镜面法向向量 = -太阳光线方向向量 - 反射后方向向量反向
    return 镜面法向向量


def 镜面坐标系计算(太阳光线方向向量, 定日镜坐标, 塔高, 安装高度):
    法向量 = 定日镜法向量(太阳光线方向向量, 定日镜坐标, 塔高, 安装高度)
    
    x1_1 = 法向量[1] / sqrt(法向量[0] ** 2 + 法向量[1] ** 2)
    x1_2 = -x1_1
    y1_1 = -(法向量[0] * x1_1) / 法向量[1]
    y1_2 = -y1_1
    
    x轴向量_1 = np.matrix(np.array([x1_1, y1_1, 0])).astype(float)
    x轴向量_2 = np.matrix(np.array([x1_2, y1_2, 0])).astype(float)
    
    y轴向量_1 = np.matrix(np.cross(法向量, x轴向量_1)).astype(float)
    y轴向量_2 = np.matrix(np.cross(法向量, x轴向量_2)).astype(float)
    x轴向量_1 = np.array(x轴向量_1).reshape(-1)
    x轴向量_2 = np.array(x轴向量_2).reshape(-1)
    y轴向量_1 = np.array(y轴向量_1).reshape(-1)
    y轴向量_2 = np.array(y轴向量_2).reshape(-1)
    法向量 = np.array(法向量).reshape(-1)
    
    if y轴向量_1[2] > 0:
        return np.transpose([x轴向量_1, y轴向量_1, 法向量])
    else:
        return np.transpose([x轴向量_2, y轴向量_2, 法向量])


def 定日镜1阴影遮挡效率计算(定日镜_1坐标, 定日镜_2坐标, 日期, 时间, 长=6, 宽=6, 塔高=84):
    """
      定日镜1_阴影遮挡效率计算

      参数：

      定日镜_1坐标(列表):被遮挡的定日镜坐标

      定日镜_2坐标(列表)

      月份(int):几月数字

      时间(float):小时时间

      返回值：

      太阳光线向量(np数组)

      """
    太阳光线方向向量 = 太阳光线向量计算(日期, 时间)
    
    定日镜_1 = (定日镜_1坐标[0], 定日镜_1坐标[1])
    定日镜_2 = (定日镜_2坐标[0], 定日镜_2坐标[1])
    过渡矩阵_1 = 镜面坐标系计算(太阳光线方向向量, 定日镜_1, 塔高, 4)
    过渡矩阵_2 = 镜面坐标系计算(太阳光线方向向量, 定日镜_2, 塔高, 4)
    定日镜_2_四角_镜面_2_坐标系 = [[-宽 / 2, 长 / 2, 0], [宽 / 2, 长 / 2, 0], [宽 / 2, -长 / 2, 0],
                                   [-宽 / 2, -长 / 2, 0]]
    定日镜_2_四角_地面_坐标系 = [np.dot(过渡矩阵_2, i) + 定日镜_2坐标 for i in 定日镜_2_四角_镜面_2_坐标系]
    定日镜_2_四角_镜面_1_坐标系 = [np.dot(np.linalg.inv(过渡矩阵_1), i - 定日镜_1坐标) for i in
                                   定日镜_2_四角_地面_坐标系]
    
    if sum(np.array(定日镜_2_四角_镜面_2_坐标系)[:, 2]) < 0:
        return 1
    太阳光线方向向量_镜面_1_坐标系 = np.dot(np.linalg.inv(过渡矩阵_1), 太阳光线方向向量)
    x, y, z = (定日镜_1坐标[0], 定日镜_1坐标[1], 定日镜_1坐标[2])
    z = z - 塔高
    反射后方向向量反向 = np.array(
        [x / sqrt(x ** 2 + y ** 2 + z ** 2), y / sqrt(x ** 2 + y ** 2 + z ** 2), z / sqrt(x ** 2 + y ** 2 + z ** 2)])
    
    反射太阳光线方向向量_镜面_1_坐标系 = np.dot(np.linalg.inv(过渡矩阵_1), 反射后方向向量反向)
    
    定日镜_1_四角_镜面_1_坐标系 = [[-宽 / 2, 长 / 2, 0], [宽 / 2, 长 / 2, 0], [宽 / 2, -长 / 2, 0],
                                   [-宽 / 2, -长 / 2, 0]]
    定日镜_2_四角_镜面_1_坐标系投影 = []
    定日镜_2_四角_镜面_1_坐标系投影_2 = []
    for i in range(4):
        k值_1 = -定日镜_2_四角_镜面_2_坐标系[i][2] / 太阳光线方向向量_镜面_1_坐标系[2]
        定日镜_2_四角_镜面_1_坐标系投影.append(k值_1 * 太阳光线方向向量_镜面_1_坐标系 + 定日镜_2_四角_镜面_1_坐标系[i])
        k值_2 = -定日镜_2_四角_镜面_2_坐标系[i][2] / 反射太阳光线方向向量_镜面_1_坐标系[2]
        定日镜_2_四角_镜面_1_坐标系投影_2.append(
            k值_2 * 反射太阳光线方向向量_镜面_1_坐标系 + 定日镜_2_四角_镜面_1_坐标系[i])
    poisnts_1 = 定日镜_2_四角_镜面_1_坐标系投影
    poisnts_1 = np.array(poisnts_1)[:, :2]
    hull_1 = ConvexHull(poisnts_1)
    poly_1 = Polygon(poisnts_1[hull_1.vertices])
    
    poisnts_2 = 定日镜_1_四角_镜面_1_坐标系
    poisnts_2 = np.array(poisnts_2)[:, :2]
    hull_2 = ConvexHull(poisnts_2)
    poly_2 = Polygon(poisnts_2[hull_2.vertices])
    
    poisnts_3 = 定日镜_2_四角_镜面_1_坐标系投影_2
    poisnts_3 = np.array(poisnts_3)[:, :2]
    hull_3 = ConvexHull(poisnts_3)
    poly_3 = Polygon(poisnts_3[hull_3.vertices])
    
    if poly_1.intersects(poly_2):
        阴影遮挡面积 = poly_1.intersection(poly_2).area
    else:
        阴影遮挡面积 = 0
    
    if poly_3.intersects(poly_2):
        反射遮挡面积 = poly_3.intersection(poly_2).area
    else:
        反射遮挡面积 = 0
    
    if poly_1.intersects(poly_2) & poly_3.intersects(poly_2) & poly_1.intersects(poly_3):
        三重叠遮挡面积 = poly_1.intersection(poly_2).intersection(poly_3).area
    else:
        三重叠遮挡面积 = 0
    
    实际遮挡面积 = 阴影遮挡面积 - 三重叠遮挡面积 + 反射遮挡面积
    实际遮挡率 = 实际遮挡面积 / (长 * 宽)
    return 1 - 实际遮挡率


def 阴影遮挡效率计算(定日镜坐标, 定日镜坐标列表, 日期, 时间, 长=6, 宽=6, 塔高=84):
    相对定日镜坐标列表 = 定日镜坐标列表 - 定日镜坐标
    距离排列 = {np.linalg.norm(x): x for x in 相对定日镜坐标列表}
    选中距离排列 = []
    for x in 距离排列:
        if 1 < x < 20:
            选中距离排列.append(x)
    效率列表 = []
    for key in 选中距离排列:
        if key != None:
            定日镜_2坐标 = [a + b for a, b in zip(定日镜坐标, 距离排列[key])]
            效率 = 定日镜1阴影遮挡效率计算(定日镜坐标, 定日镜_2坐标, 日期, 时间, 长=6, 宽=6, 塔高=84)
            效率列表.append(效率)
    效率列表.append(1)
    return min(效率列表)


def 余弦效率计算(太阳光线方向向量, 定日镜法向量):
    太阳光线方向向量模 = sqrt(太阳光线方向向量[0] ** 2 + 太阳光线方向向量[1] ** 2 + 太阳光线方向向量[2] ** 2)
    定日镜法向量模 = sqrt(定日镜法向量[0] ** 2 + 定日镜法向量[1] ** 2 + 定日镜法向量[2] ** 2)
    return -np.dot(太阳光线方向向量, 定日镜法向量) / (太阳光线方向向量模 * 定日镜法向量模)


def 大气透射率计算(定日镜坐标, 塔高=84):
    x, y, z = (定日镜坐标[0], 定日镜坐标[1], 定日镜坐标[2])
    z = z - 塔高
    D = sqrt(x ** 2 + y ** 2 + z ** 2)
    return 0.99321 - 0.0001176 * D + (1.97e-8) * D ** 2


def 截断效率计算(定日镜坐标, 日期, 时间, 长=6, 宽=6, 塔高=84):
    太阳光线方向向量 = 太阳光线向量计算(日期, 时间)
    
    定日镜 = (定日镜坐标[0], 定日镜坐标[1])
    
    过渡矩阵 = 镜面坐标系计算(太阳光线方向向量, 定日镜, 塔高, 定日镜坐标[2])
    定日镜_1_四角_镜面_1_坐标系 = [[-宽 / 2, 长 / 2, 0], [宽 / 2, 长 / 2, 0], [宽 / 2, -长 / 2, 0],
                                   [-宽 / 2, -长 / 2, 0]]
    定日镜_1_四角_地面_坐标系 = [np.dot(过渡矩阵, i) + 定日镜坐标 for i in 定日镜_1_四角_镜面_1_坐标系]
    
    x, y, z = (定日镜坐标[0], 定日镜坐标[1], 定日镜坐标[2])
    z = z - 塔高
    
    反射后方向向量 = np.array([-x / (l := sqrt(x ** 2 + y ** 2 + z ** 2)), -y / l, -z / l])
    
    # 三个向量已归一化
    集热器坐标系法向量 = [x / sqrt(x ** 2 + y ** 2), y / sqrt(x ** 2 + y ** 2), 0]
    
    集热器坐标系y轴向量 = [0, 0, 1]
    集热器坐标系x轴向量 = np.cross(集热器坐标系法向量, 集热器坐标系y轴向量)
    
    集热器坐标系过渡矩阵 = np.transpose([集热器坐标系x轴向量, 集热器坐标系y轴向量, 集热器坐标系法向量])
    
    集热器坐标系逆矩阵 = np.linalg.inv(集热器坐标系过渡矩阵)
    反射后方向向量_集热器坐标系 = np.dot(集热器坐标系逆矩阵, 反射后方向向量)
    
    定日镜_1_四角_集热器_坐标系 = [np.dot(集热器坐标系逆矩阵, i - [0, 0, 塔高]) for i in 定日镜_1_四角_地面_坐标系]
    定日镜_1_四角_集热器_坐标系投影 = []
    for i in range(4):
        k值 = -定日镜_1_四角_集热器_坐标系[i][2] / 反射后方向向量_集热器坐标系[2]
        定日镜_1_四角_集热器_坐标系投影.append(k值 * 反射后方向向量_集热器坐标系 + 定日镜_1_四角_集热器_坐标系[i])
    D = sqrt(x ** 2 + y ** 2 + z ** 2)
    
    散布 = D * tan(0.00465)
    
    集热器范围 = [[-4 + 散布, 3.5 - 散布], [4 - 散布, 3.5 - 散布], [4 - 散布, -3.5 + 散布], [-4 + 散布, -3.5 + 散布]]
    a = 0
    
    for i in 定日镜_1_四角_集热器_坐标系投影:
        if 判断点是否在四边形内部((i[0], i[1]), 集热器范围):
            a = a + 1
    if a == 4:
        return 1
    
    x_list = np.array(定日镜_1_四角_集热器_坐标系投影)[:, 0]
    y_list = np.array(定日镜_1_四角_集热器_坐标系投影)[:, 1]
    x1 = min(x_list)
    x2 = max(x_list)
    y1 = min(y_list)
    y2 = max(y_list)
    分子 = 0
    分母 = 0
    for i in range(100):
        x0 = random.uniform(x1, x2)
        y0 = random.uniform(y1, y2)
        while not 判断点是否在四边形内部((x0, y0), np.transpose([x_list, y_list])):
            x0 = random.uniform(x1, x2)
            y0 = random.uniform(y1, y2)
        d_x = random.uniform(-散布, 散布)
        d_y = random.uniform(-散布, 散布)
        while d_x ** 2 + d_y ** 2 > 散布 ** 2:
            d_x = random.uniform(-散布, 散布)
            d_y = random.uniform(-散布, 散布)
        x0, y0 = x0 + d_x, y0 + d_y
        if 判断点是否在四边形内部((x0, y0), [[-4, 3.5], [4, 3.5], [4, -3.5], [-4, -3.5]]):
            分子 = 分子 + 1
            分母 = 分母 + 1
        else:
            分母 = 分母 + 1
    return 分子 / 分母


def 判断点是否在四边形内部(point, vertices):
    """
    判断点是否在四边形内部

    Args:
      point: 待判断的点坐标，形如 (x, y)
      vertices: 四边形的四个顶点坐标列表，形如 [(x1, y1), (x2, y2), (x3, y3), (x4, y4)]

    Returns:
      bool: True 表示点在四边形内部，False 表示不在

    """
    
    def 计算三角形面积(p1, p2, p3):
        x1, y1 = p1
        x2, y2 = p2
        x3, y3 = p3
        return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2)
    
    def 判断点是否在三角形内部(point, p1, p2, p3):
        # 计算三角形的面积
        total_area = 计算三角形面积(p1, p2, p3)
        area1 = 计算三角形面积(point, p2, p3)
        area2 = 计算三角形面积(p1, point, p3)
        area3 = 计算三角形面积(p1, p2, point)
        
        # 检查点是否在三角形内部
        return area1 + area2 + area3 <= total_area
    
    a, b, c, d = vertices
    return 判断点是否在三角形内部(point, a, b, c) or 判断点是否在三角形内部(point, a, c, d)


def 时刻平均光学效率(月份, 时间):
    定日镜坐标列表 = pd.read_excel('第三问定日镜坐标.xlsx')
    定日镜坐标列表 = np.transpose(定日镜坐标列表.values)
    x = np.vstack((定日镜坐标列表, np.full(定日镜坐标列表.shape[1], 6)))
    阴影遮挡效率列表 = []
    余弦效率列表 = []
    截断效率列表 = []
    光学效率列表 = []
    for n in range(0, 1459, 1):
        定日镜坐标 = [x[0, n], x[1, n], x[2, n]]
        a = 阴影遮挡效率计算(定日镜坐标, np.transpose(x), 月份, 时间)
        阴影遮挡效率列表.append(a)
        b = 余弦效率计算(太阳光线方向向量 := 太阳光线向量计算(月份, 时间), 定日镜法向量(太阳光线方向向量, 定日镜坐标))
        余弦效率列表.append(b)
        c = 大气透射率计算(定日镜坐标)
        d = 截断效率计算(定日镜坐标, 月份, 时间)
        截断效率列表.append(d)
        光学效率 = 0.92 * a * b * c
        光学效率列表.append(光学效率)
    平均阴影遮挡效率 = sum(阴影遮挡效率列表) / 1459
    平均余弦效率 = sum(余弦效率列表) / 1459
    平均截断效率 = sum(截断效率列表) / 1459
    平均光学效率 = sum(光学效率列表) / 1459
    return 平均阴影遮挡效率, 平均余弦效率, 平均截断效率, 平均光学效率


def test():
    日平均阴影遮挡效率列表 = []
    日平均余弦效率列表 = []
    日平均截断效率列表 = []
    日平均光学效率列表 = []
    for i in range(1, 13, 1):
        日阴影遮挡效率 = 0
        日余弦效率 = 0
        日截断效率 = 0
        日光学效率 = 0
        for j in [9, 10.5, 12, 13.5, 15]:
            时刻阴影遮挡效率, 时刻余弦效率, 时刻截断效率, 时刻光学效率 = 时刻平均光学效率(i, j)
            日阴影遮挡效率 += 时刻阴影遮挡效率
            日余弦效率 += 时刻余弦效率
            日截断效率 += 时刻截断效率
            日光学效率 += 时刻光学效率
        日平均阴影遮挡效率列表.append(日阴影遮挡效率 / 5)
        日平均余弦效率列表.append(日余弦效率 / 5)
        日平均截断效率列表.append(日截断效率 / 5)
        日平均光学效率列表.append(日光学效率 / 5)
    print('日平均阴影遮挡效率列表:', 日平均阴影遮挡效率列表)
    print('日平均余弦效率列表:', 日平均余弦效率列表)
    print('日平均截断效率列表:', 日平均截断效率列表)
    print('日平均光学效率列表:', 日平均光学效率列表)


test()


